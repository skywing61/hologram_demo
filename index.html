<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>雙眼離軸投影 (Android WebView Client)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: monospace;
            touch-action: none;
            /* 禁止瀏覽器預設的縮放與捲動行為，這對觸控操作很重要 */
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border: 1px solid #0f0;
            z-index: 999;
            pointer-events: none;
            display: none;
            /* 隱藏左上角 UI */
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #424242;
            display: none;
            font-size: 1.2rem;
            text-align: center;
        }

        /* 狀態提示，方便除錯 */
        #debug-status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #666;
            font-size: 12px;
            z-index: 50;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <div id="info">
        <h3 style="margin:0">Dual-Eye Off-Axis</h3>
        <p>Android Client Mode</p>
        <p>Head X: <span id="hx">0</span></p>
        <p>Head Y: <span id="hy">0</span></p>
    </div>

    <div id="loading">載入 3D 模型中...</div>
    <!-- <div id="debug-status">等待 Android 訊號...</div> -->

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // 全域變數宣告
        let scene, renderer, camera;
        let customModel;

        // 互動控制變數
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let lastTouchDistance = 0; // 用於雙指縮放

        // === 設定參數 ===
        const SCREEN_WIDTH = 20;
        const SCREEN_HEIGHT = 11.25;
        const OBSERVER_DISTANCE = 15;
        const EYE_SEPARATION = 1.2;

        // 頭部位置
        const headPos = new THREE.Vector3(0, 0, OBSERVER_DISTANCE);
        const targetHeadPos = new THREE.Vector3(0, 0, OBSERVER_DISTANCE);

        init();
        animate();

        // === 初始化函式 ===
        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setScissorTest(true);
            document.body.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xeeeeee);

            // 燈光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 2);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

            setupScene();

            // 加入互動監聽 (滑鼠與觸控)
            addInteraction();

            window.addEventListener('resize', onWindowResize);

            // === 暴露給 Android WebView 呼叫的函式 ===
            window.updateHeadPosition = function (x, y) {
                // x, y 預期為 0.0 ~ 1.0 的正規化座標
                // 0.5, 0.5 代表螢幕中心

                const sensitivity = 2.0;
                const SENSITIVITY_X = SCREEN_WIDTH * sensitivity;
                const SENSITIVITY_Y = SCREEN_HEIGHT * sensitivity;

                // 更新目標位置
                targetHeadPos.x = (0.5 - x) * SENSITIVITY_X;
                targetHeadPos.y = (0.5 - y) * SENSITIVITY_Y;
            };
        }

        // === 新增：互動控制函式 ===
        function addInteraction() {
            const canvas = renderer.domElement;

            // --- 滑鼠事件 ---
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging || !customModel) return;

                const deltaMove = {
                    x: e.offsetX - previousMousePosition.x,
                    y: e.offsetY - previousMousePosition.y
                };

                // 旋轉模型 (Y軸左右轉，X軸上下轉)
                const rotateSpeed = 0.005;
                customModel.rotation.y += deltaMove.x * rotateSpeed;
                customModel.rotation.x += deltaMove.y * rotateSpeed;

                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });

            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('mouseleave', () => isDragging = false);

            // 滑鼠滾輪縮放
            canvas.addEventListener('wheel', (e) => {
                if (!customModel) return;
                e.preventDefault(); // 防止網頁捲動

                const scaleSpeed = 0.001;
                // 限制縮放範圍，避免消失或過大
                const minScale = 1.0;
                const maxScale = 100.0;

                // 根據滾輪方向計算係數
                // e.deltaY > 0 是滾輪向下(縮小)，< 0 是向上(放大)
                let scaleFactor = 1 - e.deltaY * scaleSpeed;

                // 套用縮放
                const newScaleX = customModel.scale.x * scaleFactor;

                // 簡單檢查範圍 (只檢查X軸作為代表)
                if (newScaleX > minScale && newScaleX < maxScale) {
                    customModel.scale.multiplyScalar(scaleFactor);
                }
            }, { passive: false });


            // --- 觸控事件 (支援單指旋轉，雙指縮放) ---
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isDragging = true;
                    previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    isDragging = false; // 雙指時停止旋轉
                    // 計算初始雙指距離
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                if (!customModel) return;
                e.preventDefault(); // 防止滑動頁面

                if (e.touches.length === 1 && isDragging) {
                    // 單指旋轉
                    const deltaMove = {
                        x: e.touches[0].clientX - previousMousePosition.x,
                        y: e.touches[0].clientY - previousMousePosition.y
                    };

                    const rotateSpeed = 0.005;
                    customModel.rotation.y += deltaMove.x * rotateSpeed;
                    customModel.rotation.x += deltaMove.y * rotateSpeed;

                    previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };

                } else if (e.touches.length === 2) {
                    // 雙指縮放
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const currentDistance = Math.sqrt(dx * dx + dy * dy);

                    if (lastTouchDistance > 0) {
                        const scaleFactor = currentDistance / lastTouchDistance;

                        // 稍微平滑化縮放
                        const smoothFactor = 1 + (scaleFactor - 1) * 0.8;

                        const minScale = 1.0;
                        const maxScale = 100.0;
                        const newScaleX = customModel.scale.x * smoothFactor;

                        if (newScaleX > minScale && newScaleX < maxScale) {
                            customModel.scale.multiplyScalar(smoothFactor);
                        }
                    }
                    lastTouchDistance = currentDistance;
                }
            }, { passive: false });

            canvas.addEventListener('touchend', () => {
                isDragging = false;
                lastTouchDistance = 0;
            });
        }

        // === 核心渲染迴圈 ===
        function animate() {
            requestAnimationFrame(animate);

            // 平滑移動 (Lerp)
            headPos.lerp(targetHeadPos, 0.1);

            // 更新 UI 顯示 (如果 #info 是顯示的)
            if (document.getElementById('info').style.display !== 'none') {
                document.getElementById('hx').innerText = headPos.x.toFixed(2);
                document.getElementById('hy').innerText = headPos.y.toFixed(2);
            }

            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            // 左眼渲染
            const leftEyeX = headPos.x - (EYE_SEPARATION / 2);
            updateOffAxisCamera(camera, leftEyeX, headPos.y, headPos.z);
            renderer.setViewport(0, 0, windowWidth / 2, windowHeight);
            renderer.setScissor(0, 0, windowWidth / 2, windowHeight);
            renderer.render(scene, camera);

            // 右眼渲染
            const rightEyeX = headPos.x + (EYE_SEPARATION / 2);
            updateOffAxisCamera(camera, rightEyeX, headPos.y, headPos.z);
            renderer.setViewport(windowWidth / 2, 0, windowWidth / 2, windowHeight);
            renderer.setScissor(windowWidth / 2, 0, windowWidth / 2, windowHeight);
            renderer.render(scene, camera);
        }

        function updateOffAxisCamera(cam, eyeX, eyeY, eyeZ) {
            cam.position.set(eyeX, eyeY, eyeZ);
            cam.rotation.set(0, 0, 0);
            cam.updateMatrixWorld();

            const screenRight = SCREEN_WIDTH / 2;
            const screenLeft = -SCREEN_WIDTH / 2;
            const screenTop = SCREEN_HEIGHT / 2;
            const screenBottom = -SCREEN_HEIGHT / 2;

            const near = 0.1;
            const far = 1000;
            // 避免 eyeZ 為 0 導致除以零錯誤
            const safeEyeZ = Math.max(eyeZ, 0.1);
            const ratio = near / safeEyeZ;

            const left = (screenLeft - eyeX) * ratio;
            const right = (screenRight - eyeX) * ratio;
            const top = (screenTop - eyeY) * ratio;
            const bottom = (screenBottom - eyeY) * ratio;

            cam.projectionMatrix.makePerspective(left, right, top, bottom, near, far);
        }

        function onWindowResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setupScene() {
            const loader = new GLTFLoader();
            const loadingEl = document.getElementById('loading');
            loadingEl.style.display = 'block';

            // 載入模型 (相對路徑)
            const modelUrl = './source/Seen_low_2K.glb';

            loader.load(
                modelUrl,
                function (gltf) {
                    customModel = gltf.scene;
                    // 調整模型位置與大小
                    const scale = 30.0;
                    customModel.scale.set(scale, scale * 0.6, scale);
                    customModel.position.set(-1, -1, -5);
                    customModel.rotation.y = 0.8;
                    scene.add(customModel);

                    loadingEl.style.display = 'none';
                    console.log("Model loaded!");
                },
                undefined,
                function (error) {
                    console.error(error);
                    loadingEl.innerText = "模型載入失敗 (請確認檔案位置)";
                }
            );
        }
    </script>
</body>

</html>